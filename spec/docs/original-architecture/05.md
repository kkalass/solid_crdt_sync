## 5. Architectural Data Layers

Having established the fundamental concepts of identity and lifecycle management, we can now examine how CRDT-managed resources are structured and organized. The architecture is composed of four distinct layers, moving from the fundamental structure of the data to the high-level strategies used by an application.

### 5.1. Layer 1: The Data Resource

This layer defines the atomic unit of data: a single, self-contained RDF resource. Its primary purpose is to describe a "thing" using standard vocabularies.

* **Format:** Data is stored as a single RDF resource. It uses a fragment identifier (e.g., `#it`) to distinguish the "thing" being described from the document that describes it.

* **Vocabulary:** The primary data uses well-known public or custom vocabularies (e.g., `schema.org`).

* **Structure:** The resource is clean and focused on the data's payload. It contains pointers to the other architectural layers. For a clean separation of concerns, it is recommended to store data and indices in separate top-level containers (e.g., `/data/` and `/indices/`). However, a compliant client must always use the Solid Type Index as the definitive source for discovering these locations, as a user may choose to configure different paths.

#### Example Application Context

The following examples demonstrate the architecture using a **meal planning application** that manages recipes, meal plans, and automatically generates shopping lists from planned meals. This integrated workflow shows how different data types can reference each other while maintaining clean separation of concerns.

**Example: A recipe resource at `https://alice.podprovider.org/data/recipes/tomato-basil-soup`**

This resource uses a semantic IRI based on the recipe name. The resource describes a recipe and contains metadata linking it to other architectural layers.

```turtle
@prefix schema: <https://schema.org/> .
@prefix sync: <https://w3id.org/solid-crdt-sync/vocab/sync#> .
@prefix idx: <https://w3id.org/solid-crdt-sync/vocab/idx#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix : <#> .

# -- The "Thing" Itself (The Payload) --
:it a schema:Recipe;
   schema:name "Tomato Soup" ;
   schema:keywords "vegan", "soup" ;
   schema:recipeIngredient "2 lbs fresh tomatoes", "1 cup fresh basil" ;
   schema:totalTime "PT30M" .

# -- Pointers to Other Layers --
<> a sync:ManagedDocument;
   foaf:primaryTopic :it;
   # Pointer to the Merge Contract (Layer 2) - imports CRDT library + app mappings
   sync:isGovernedBy <https://kkalass.github.io/meal-planning-app/crdt-mappings/recipe-v1> ;
   # Pointer to the specific index shard this resource belongs to
   idx:belongsToIndexShard <../../indices/recipes/index-full-a1b2c3d4/shard-mod-md5-2-0-v1_0_0> .
```

### 5.2. Layer 2: The Merge Contract

This layer defines the "how" of data integrity. It is a public, application-agnostic contract that ensures any two applications can merge the same data and arrive at the same result. It consists of two parts: the high-level rules and the low-level mechanics.

**Fundamental Principle:** All documents stored in user Pods by this framework (except for the standard solid type index which cannot be fully managed by us) are designed to be merged using the CRDT mechanics described in this layer. This ensures deterministic conflict resolution and maintains data consistency across distributed installations.

* **The Rules (`sync:` vocabulary):** A separate, published RDF file defines the merge behavior for a class of data by linking its properties to specific CRDT algorithms.

* **The Mechanics (`crdt:` vocabulary):** To execute the rules, low-level metadata is embedded within the data resource itself. This includes **Hybrid Logical Clocks** for versioning and **Document Tombstones** for managing deletions.

#### 5.2.1. Merge Contract Fundamentals

**What Are Merge Contracts?**

Merge contracts are public RDF documents that define how to resolve conflicts when merging data from multiple sources. They act as "rule books" that ensure any two CRDT-enabled applications can merge the same data and arrive at identical results.

**Critical: Contracts Are Hosted Externally, Not in User Pods**

Merge contracts are **published by application authors or this specification at stable internet URIs** (e.g., `https://kkalass.github.io/meal-planning-app/crdt-mappings/recipe-v1`), not stored in user Pods. This separation is essential because:
- **Stability:** Contracts must remain accessible even if individual user Pods are offline
- **Interoperability:** Multiple applications can reference the same contract without coordination
- **Version control:** Application authors manage contract evolution independently of user data
- **Trust:** Users can inspect the merge rules their data follows by examining public contracts

**How Merge Contracts Work:**

1. **Property-to-CRDT Mapping:** Each RDF property is linked to a specific CRDT algorithm (LWW-Register, OR-Set, etc.)
2. **External Reference:** Resources point to their merge contract via `sync:isGovernedBy` using stable internet URIs
3. **Deterministic Merging:** Applications follow the published rules to merge conflicting changes
4. **Interoperability:** Different applications using the same contracts can safely collaborate

**The Two Scoping Approaches:**

The framework supports two different ways to define merge rules, each serving different purposes:

**Property Mapping (Class-Scoped Rules):**
- Rules defined within `mc:ClassMapping` apply **only within that specific class context**
- Example: `rdf:subject` might use LWW-Register when within `rdf:Statement` resources, but different rules elsewhere
- **Use case:** When the same predicate needs different merge behavior in different contexts

```turtle
# Property mapping: rdf:subject behavior scoped to rdf:Statement context
mappings:statement-v1 a mc:ClassMapping;
   mc:appliesToClass rdf:Statement;
   mc:rule
     [ mc:predicate rdf:subject; algo:mergeWith algo:LWW_Register ] .
```

**Predicate Mapping (Global Rules):**
- Rules defined within `mc:PredicateMapping` apply **globally across all contexts**
- Example: `crdt:installationId` **always** uses LWW-Register regardless of which resource contains it
- **Use case:** Framework-level predicates that need consistent behavior everywhere

```turtle
# Predicate mapping: Global behavior across all contexts
<#clock-mappings> a mc:PredicateMapping;
   mc:rule
     [ mc:predicate crdt:installationId; algo:mergeWith algo:LWW_Register; mc:isIdentifying true ],
     [ mc:predicate crdt:logicalTime; algo:mergeWith algo:LWW_Register ],
     [ mc:predicate crdt:physicalTime; algo:mergeWith algo:LWW_Register ],
     [ mc:predicate crdt:deletedAt; algo:mergeWith algo:OR_Set ] .
```

**Why Both Are Needed:**

- **Framework predicates** (like `crdt:installationId`, `crdt:deletedAt`) need consistent behavior across all resources → Global predicate mappings
- **Application data** (like `schema:name`, `schema:keywords`) may need context-specific behavior → Class-scoped property mappings
- **Hybrid approach** allows framework consistency while enabling application flexibility

**Semantic Impact:** This distinction is crucial for understanding merge behavior. A predicate like `schema:name` might use LWW-Register when within `schema:Recipe` resources but could theoretically use OR-Set when within `schema:Organization` resources if different mapping contracts specify different behaviors. However, framework predicates like `crdt:installationId` and `crdt:deletedAt` maintain consistent semantics everywhere through global predicate mappings.

#### 5.2.2. Merge Contract Import Hierarchy and Examples

This section demonstrates how the hierarchical import system works in practice, showing how framework-provided mappings are reused across different application domains.

##### 5.2.2.1. Framework Import Mechanism

The framework provides a reusable mapping library (`mappings:core-v1`) that defines standard behavior for all CRDT infrastructure predicates. Applications import this library and add their domain-specific rules on top.

##### 5.2.2.2. Complete Example: Shopping List Entry

**Data Resource:** `https://alice.podprovider.org/data/shopping-entries/created/2024/08/weekly-shopping-001`

This resource demonstrates semantic date-based organization and shows how shopping list entries integrate with the meal planning workflow.

```turtle
@prefix schema: <https://schema.org/> .
@prefix sync: <https://w3id.org/solid-crdt-sync/vocab/sync#> .
@prefix idx: <https://w3id.org/solid-crdt-sync/vocab/idx#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix meal: <https://example.org/vocab/meal#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix : <#> .

# -- The Shopping List Entry (The Payload) --
:it a meal:ShoppingListEntry;
   schema:name "2 lbs fresh tomatoes" ;
   meal:quantity "2" ;
   meal:unit "lbs" ;
   # Links to the source recipe that generated this shopping item
   meal:derivedFrom <../../../../recipes/tomato-basil-soup#it> ;
   # Links to the meal plan date that requires this ingredient
   meal:requiredForDate "2024-08-15"^^xsd:date ;
   schema:dateCreated "2024-08-10T10:30:00Z"^^xsd:dateTime .

# -- Pointers to Other Layers --
<> a sync:ManagedDocument;
   foaf:primaryTopic :it;
   # Uses a different DocumentMapping for shopping list entries (imports CRDT library + shopping mappings)
   sync:isGovernedBy <https://kkalass.github.io/meal-planning-app/crdt-mappings/shopping-entry-v1> ;
   # Points to index shard within the appropriate group
   idx:belongsToIndexShard <../../../../../indices/shopping-entries/index-grouped-e5f6g7h8/groups/2024-08/shard-mod-md5-4-0-v1_0_0> .
```

**Following the Merge Contract Link: shopping-entry-v1**

Now let's examine what the `shopping-entry-v1` merge contract actually contains. This shows how the framework imports standard CRDT mappings and defines application-specific rules:

```turtle
# At https://kkalass.github.io/meal-planning-app/crdt-mappings/shopping-entry-v1
@prefix sync: <https://w3id.org/solid-crdt-sync/vocab/sync#> .
@prefix mc: <https://w3id.org/solid-crdt-sync/vocab/merge-contract#> .
@prefix algo: <https://w3id.org/solid-crdt-sync/vocab/crdt-algorithms#> .
@prefix crdt: <https://w3id.org/solid-crdt-sync/vocab/crdt-mechanics#> .
@prefix mappings: <https://w3id.org/solid-crdt-sync/mappings/> .
@prefix schema: <https://schema.org/> .
@prefix meal: <https://example.org/vocab/meal#> .

<> a mc:DocumentMapping;
   # Import the standard CRDT vocabulary mappings (framework-provided)
   mc:imports ( mappings:core-v1 );
   
   # Define shopping-specific property mappings
   mc:classMapping ( [
     a mc:ClassMapping;
     mc:appliesToClass meal:ShoppingListEntry;
     mc:rule
       [ mc:predicate schema:name; algo:mergeWith algo:LWW_Register ],
       [ mc:predicate meal:quantity; algo:mergeWith algo:LWW_Register ],
       [ mc:predicate meal:unit; algo:mergeWith algo:LWW_Register ],
       [ mc:predicate meal:derivedFrom; algo:mergeWith algo:LWW_Register ],
       [ mc:predicate meal:requiredForDate; algo:mergeWith algo:LWW_Register ],
       [ mc:predicate schema:dateCreated; algo:mergeWith algo:LWW_Register ]
   ] ) .
```

##### 5.2.2.3. The Contract Hierarchy

**How Import Resolution Works:**

1. **Framework Import:** `mc:imports ( mappings:core-v1 )` brings in standard CRDT framework mappings for infrastructure predicates like `crdt:installationId`, `crdt:deletedAt`, `crdt:logicalTime`. These use global predicate mappings for consistent behavior across all contexts.

2. **Application Rules:** The local `mc:classMapping` defines domain-specific merge behavior for `meal:ShoppingListEntry` properties. All properties use `algo:LWW_Register` since shopping items are typically single-user managed.

3. **Precedence Resolution:** Conflicts are resolved using deterministic precedence order following the specificity principle (why `rdf:List` is used instead of multi-valued properties):
   1. **Local Class Mappings** (highest priority) - `mc:classMapping` 
   2. **Imported Class Mappings** - from `mc:imports` libraries
   3. **Local Predicate Mappings** - `mc:predicateMapping`
   4. **Imported Predicate Mappings** (lowest priority) - from `mc:imports` libraries
   
   **Key Principle:** Context-specific rules (class mappings) win over global rules (predicate mappings), regardless of local vs imported source. This ensures that specific behaviors defined for particular contexts aren't accidentally overridden by general global rules.


#### 5.2.3. Hybrid Logical Clock Mechanics

The state-based merge process uses **document-level Hybrid Logical Clocks (HLC)** for causality determination and intuitive tie-breaking. Each resource document has a single HLC that tracks changes to the entire document using both logical time (causality) and physical time (wall-clock).

**Hybrid Logical Clock Structure:**

```turtle
<> crdt:hasClockEntry [
    crdt:installationId <https://alice.podprovider.org/installations/550e8400-e29b-41d4-a716-446655440000> ;
    crdt:logicalTime "15"^^xsd:long ;  # Causality counter (tamper-proof)
    crdt:physicalTime "1693824600000"^^xsd:long  # Wall-clock timestamp (intuitive tie-breaking)
  ] ,
  [
    crdt:installationId <https://bob.podprovider.org/installations/6ba7b810-9dad-11d1-80b4-00c04fd430c8> ;
    crdt:logicalTime "8"^^xsd:long ;
    crdt:physicalTime "1693824550000"^^xsd:long
  ] ;
  # Pre-calculated hash for efficient index operations (includes both logical and physical times)
  crdt:clockHash "xxh64:abcdef1234567890" .  # Framework standard: xxh64 algorithm
```

**CRDT Literature Mapping:** The `crdt:installationId` property corresponds to what CRDT literature typically calls "client ID" or "node ID." We use "installation" to distinguish from Solid OIDC client identifiers, which identify applications rather than specific installation instances.

**Clock Entry Identification:**

Hybrid Logical Clock entries are context-identified blank nodes using the pattern:
`(document_IRI, crdt:installationId=<installation_IRI>)`

**Merge Process:**
1. **Causality Determination:** Compare logical clocks to determine document causality relationships
2. **Physical Time Tie-Breaking:** For concurrent logical operations, use physical time for "most recent wins" semantics
3. **Property-by-Property Merging:** Apply CRDT rules (LWW-Register, OR-Set, etc.) to individual properties
4. **Clock Updates:** Merge Hybrid Logical Clocks using standard union algorithms (max logical times, max physical times)

**Benefits of Hybrid Logical Clocks:**
- **Tamper-Resistant Causality:** Logical time protects against clock manipulation
- **Intuitive Tie-Breaking:** Physical time provides "newer wins" semantics
- **Related Change Coherence:** Operations done together tend to win/lose together across properties and documents
- **Clock Skew Tolerance:** Physical time bias doesn't affect convergence, only fairness

**Detailed Algorithms:** For comprehensive merge algorithms, Hybrid Logical Clock mechanics, and edge case handling, see [CRDT-SPECIFICATION.md](CRDT-SPECIFICATION.md).

#### 5.2.4. Vocabulary Versioning and Evolution

**Versioning Strategy:**

The specification uses simple integer versioning for merge contracts to handle evolution over time:

```turtle
# Merge contract versioning examples
sync:isGovernedBy <https://kkalass.github.io/meal-planning-app/crdt-mappings/recipe-v1> .
sync:isGovernedBy <https://kkalass.github.io/meal-planning-app/crdt-mappings/recipe-v2> .
```

**When to Increment Versions:**

**Backward Compatible (same version):**
- Adding new optional properties
- Adding new CRDT types to vocabulary
- Documentation updates

**Breaking Changes (new version required):**
- Changing property semantics or constraints
- Removing/renaming existing properties
- Incompatible CRDT merge behavior changes

**Client Compatibility:**
- Clients handle unknown properties by defaulting to `crdt:LWW_Register` merge behavior when using known contracts
- Different or unknown contracts trigger fallback to document-level `crdt:LWW_Register` (entire resource wins based on Hybrid Logical Clock)
- Framework vocabularies evolve through major version URI changes when needed

### 5.3. Layer 3: The Indexing Layer

This layer is **vital for change detection and synchronization efficiency**. It defines a convention for how data can be indexed for fast access and change monitoring. While the amount of header information stored in indices is optional (some may contain only Hybrid Logical Clock hashes), the indexing layer itself is required for the framework to efficiently detect when resources have changed. For detailed sharding algorithms and performance optimization strategies, see [SHARDING.md](SHARDING.md) and [PERFORMANCE.md](PERFORMANCE.md).

#### 5.3.1. Index Architecture Overview

The framework provides two fundamental indexing approaches to handle different data organization patterns:

**FullIndex (Monolithic Approach):**
- **Purpose:** Single index covering an entire dataset
- **Use cases:** Bounded, searchable collections where you want global access
- **Examples:** Personal recipe collection, document library, contact list
- **Structure:** One index with multiple shards for performance (technical partitioning)
- **Benefits:** Simple discovery, global search capabilities, unified management

**GroupIndexTemplate + GroupIndex (Grouped Approach):**
- **Purpose:** Data split into logical groups, each with its own index
- **Use cases:** Unbounded or naturally-grouped data where you work with specific subsets
- **Examples:** Shopping entries by month, financial transactions by year, email by folder
- **Structure:** Template defines grouping rules, individual GroupIndex instances for each group
- **Benefits:** Scales to unlimited data size, efficient partial sync, natural organization

**Key Architectural Distinction:**
- **Groups** = Logical organization (August 2024 shopping entries, Italian recipes, Q3 transactions)
- **Shards** = Technical performance optimization (split large indices for parallel processing)

**When to Choose Each Pattern:**

| Pattern | Best For | Examples | Scaling |
|---------|----------|----------|---------|
| **FullIndex** | Bounded datasets you browse/search globally | Recipes (≤1000s), Contacts, Documents | Limited by total size |
| **GroupIndexTemplate** | Unbounded datasets with natural groupings | Shopping by month, Transactions by year | Unlimited (groups stay small) |

**Index Convention:** Indices are separate CRDT resources that **minimally contain a lightweight hash of each document's Hybrid Logical Clock** for change detection. They may optionally contain additional "header" information extracted from **resource properties** (like `schema:name`, `schema:dateCreated`) to support on-demand synchronization scenarios.

**Important Distinction:** While the Hybrid Logical Clock hash tracks document-level changes, the header properties come from specific resources within those documents. For example, a recipe's `schema:name` property belongs to the `recipe#it` resource, not the document itself, but gets included in index headers for efficient discovery.

**Index Entry CRDT Behavior:** All index entry properties use **LWW-Register (Last Writer Wins)** merge semantics, regardless of the CRDT algorithms used in the original indexed resources. This design choice:
- **Simplifies architecture**: Avoids complex mapping file inheritance and type registry mechanisms  
- **Recognizes index entries as cached data**: Index entries are performance optimizations, not authoritative sources
- **Provides acceptable trade-offs**: Slight inconsistencies between index and source data are less critical than system simplicity
- **Enables self-healing**: Index entries can be regenerated from authoritative sources if inconsistencies become problematic
- **Maintains predictable semantics**: "Last installation to update this index entry wins" is simple and deterministic

**Bidirectional Index Maintenance:** All index operations require updating both the index shard entries and the corresponding `idx:belongsToIndexShard` references in the indexed documents. Removing a document from an index means removing both its shard entry and updating the document to remove its `idx:belongsToIndexShard` reference to that shard. This principle applies to all indexing operations: population, cleanup, document updates, and maintenance tasks.

#### 5.3.2. Framework Vocabulary

The `idx:` vocabulary provides the building blocks for both indexing approaches:

**Core Index Classes:**
* **`idx:Index`:** The abstract base class for any sharded index that directly contains data entries.
* **`idx:FullIndex`:** A concrete, monolithic index for a dataset. It is used when a `GroupIndexTemplate` is not required. It inherits from `idx:Index`.
* **`idx:GroupIndexTemplate`:** A "rulebook" resource that defines *how* a data type is grouped. It does **not** contain data entries itself.
* **`idx:GroupIndex`:** A concrete index representing a single group (e.g., "August 2024"). It inherits from `idx:Index` and links back to its `GroupIndexTemplate` rulebook.
* **`idx:Shard`:** A technical partition within an index containing actual entry data.

**Framework Properties:**
* **`idx:indexesClass`:** Links index to the RDF class it indexes (e.g., schema:Recipe)
* **`idx:indexedProperty`:** Specifies which properties to include in index headers
* **`idx:hasShard`:** Links index to its component shards
* **`idx:belongsToIndexShard`:** Links data resource to its index shard
* **`idx:basedOn`:** Links GroupIndex back to its GroupIndexTemplate
* **`idx:isShardOf`:** Links shard back to its parent index
* **`idx:containsEntry`:** Contains an index entry with resource IRI and metadata
* **`idx:resource`:** Points to the actual data resource from an index entry

**Indexing Flexibility:** While most indices focus on primary resources (like `recipe#it`), the framework supports indexing any resource within a document. For example, a recipe document could have both a recipe index (indexing `recipe#it` for name, prep time) and a nutrition index (indexing `recipe#nutrition` for calories, protein). Both resources sync together via the same document-level Hybrid Logical Clock but serve different discovery purposes.
* **`idx:groupedBy`:** Links GroupIndexTemplate to its GroupingRule
* **`idx:property`:** Multi-value property linking to GroupingRuleProperty instances (in GroupingRule)
* **`idx:shardingAlgorithm`:** Specifies the sharding algorithm configuration
* **`idx:GroupingRule`:** Class defining how resources are assigned to groups
* **`idx:GroupingRuleProperty`:** Individual property specification within a GroupingRule
* **`idx:sourceProperty`:** Property to extract grouping value from (in GroupingRuleProperty)
* **`idx:transform`:** Optional regex transform for value normalization (in GroupingRuleProperty) - see [Group Indexing Specification](GROUP-INDEXING.md)  
* **`idx:hierarchyLevel`:** Optional hierarchy level for multi-property grouping (in GroupingRuleProperty)
* **`idx:missingValue`:** Default value when property is absent (in GroupingRuleProperty)
* **`idx:ModuloHashSharding`:** Class specifying hash-based shard distribution

#### 5.3.3. GroupingRule Specification

GroupIndexTemplate uses a GroupingRule to determine which group(s) a resource belongs to. This system supports conditional indexing (resources only indexed when certain properties are present) and multi-dimensional grouping.

For detailed information on regex transforms and group key formatting, see [Group Indexing Specification](GROUP-INDEXING.md).

**GroupingRule Algorithm:**

The GroupingRule determines group membership using the following process:

1. **Property Extraction:** For each `idx:GroupingRuleProperty`, extract all values for `idx:sourceProperty` from the resource
2. **Missing Value Handling:** If a property has no values:
   - **With `idx:missingValue`:** Use the specified default value
   - **Without `idx:missingValue`:** Return empty set (resource joins no groups)
3. **Permutation Generation:** Compute Cartesian product of all property value sets
4. **Transform Application:** Apply `idx:transform` to each value if specified
5. **Path Generation:** Generate deterministic group paths using hierarchy levels:
   - **With `idx:hierarchyLevel`:** Sort properties by level, create nested path structure
   - **Without hierarchy levels:** Sort properties by source IRI lexicographically, join with '-' separator
6. **Set Deduplication:** Convert the list of group identifiers to a set, removing duplicates that arise from different source values formatting to the same string
7. **Group Creation:** Create GroupIndex instances for all unique group identifiers

**Configuration Structure:**
```turtle
idx:groupedBy [
  a idx:GroupingRule;
  idx:property [
    a idx:GroupingRuleProperty;
    idx:sourceProperty <predicate>;     # RDF property to extract from
    idx:transform (                     # Optional value transformation list
      [
        a idx:RegexTransform;
        idx:pattern "^([0-9]{4})-([0-9]{2})-([0-9]{2})$";
        idx:replacement "${1}-${2}"
      ]
    ) ;
    idx:hierarchyLevel 1;               # Optional hierarchy level (default: 1)
    idx:missingValue "default"          # Optional default if property absent
  ];
  # No groupTemplate - paths generated deterministically
];
```

**Common Patterns:**

*Simple Time-Based Grouping:*
```turtle
idx:property [
  idx:sourceProperty schema:dateCreated;
  idx:transform (
    [
      a idx:RegexTransform;
      idx:pattern "^([0-9]{4})-([0-9]{2})-([0-9]{2})$";
      idx:replacement "${1}-${2}"
    ]
  ) .
];
# Result: groups/2024-08/index, groups/2024-09/index, etc.
```

*Hierarchical Time-Based Grouping:*
```turtle
idx:property [
  idx:sourceProperty schema:dateCreated;
  idx:transform (
    [
      a idx:RegexTransform;
      idx:pattern "^([0-9]{4})-[0-9]{2}-[0-9]{2}$";
      idx:replacement "${1}"
    ]
  ) ;
  idx:hierarchyLevel 1
], [
  idx:sourceProperty schema:dateCreated;
  idx:transform (
    [
      a idx:RegexTransform;
      idx:pattern "^[0-9]{4}-([0-9]{2})-[0-9]{2}$";
      idx:replacement "${1}"
    ]
  ) ;
  idx:hierarchyLevel 2
];
# Result: groups/2024/08/index, groups/2024/09/index, etc.
```

*Conditional Registration:*
```turtle
idx:property [
  idx:sourceProperty crdt:deletedAt;
  idx:transform (
    [
      a idx:RegexTransform;
      idx:pattern "^([0-9]{4})-[0-9]{2}-[0-9]{2}$";
      idx:replacement "${1}"
    ]
  ) .
  # No missingValue = no group if property absent
];
# Only documents WITH crdt:deletedAt get indexed
# Result: groups/2024/index, groups/2025/index, etc.
```

*Multi-Property Flat Grouping:*
```turtle
idx:property [
  idx:sourceProperty schema:dateCreated;
  idx:transform (
    [
      a idx:RegexTransform;
      idx:pattern "^([0-9]{4})-([0-9]{2})-([0-9]{2})$";
      idx:replacement "${1}-${2}"
    ]
  ) .
], [
  idx:sourceProperty schema:category
  # No transform = use property value directly
];
# Resource with dateCreated="2024-08-15", category="work"
# Result: groups/2024-08-work/index (lexicographic IRI ordering)
```

#### 5.3.4. Sharding and Performance

Both FullIndex and GroupIndex instances use **sharding** for performance optimization. This is a technical implementation detail that splits large indices into smaller, parallel-processable chunks.

**Key Principles:**
- **Deterministic assignment:** Each resource always maps to the same shard
- **Automatic scaling:** System increases shard count when size thresholds are exceeded (default: 1000 entries per shard)
- **Lazy migration:** Shard rebalancing happens opportunistically during normal operations
- **Self-describing names:** Shard names encode their configuration for automatic coordination

**Example Shard Structure:**
```turtle
<index> idx:hasShard <shard-mod-md5-4-0-v1_2_0>, <shard-mod-md5-4-1-v1_2_0>,
                     <shard-mod-md5-4-2-v1_2_0>, <shard-mod-md5-4-3-v1_2_0> .
```

**Implementation Details:** For comprehensive sharding algorithms, migration procedures, and version handling, see [SHARDING.md](SHARDING.md).

#### 5.3.5. Structure-Derived Index Naming

**Coordination-Free Index Convergence:**

Multiple CRDT-enabled applications automatically converge on shared indices through deterministic structure-derived naming, eliminating coordination overhead while ensuring compatibility.

**Deterministic Naming Pattern:**
- **FullIndex:** `index-full-${SHA256(indexedClassIRI|shardingAlgorithmClass|hashAlgorithm)}/index`
- **GroupIndexTemplate:** `index-grouped-${SHA256(groupingRuleProperties|indexedClassIRI|shardingAlgorithmClass|hashAlgorithm)}/index`
- **Hash computation:** SHA256 with pipe separators (`|`) between all structural inputs
- **Full IRI usage:** Hash computation uses complete IRIs, not prefixed forms
- **Directory structure:** Hash-derived directory name + consistent `index` document
- **GroupingRuleProperties serialization:** Each GroupingRuleProperty serialized as `sourceProperty|transformList|hierarchyLevel|missingValue`, where transformList uses canonical transform format (see below), multiple properties sorted using the same ordering rules as path generation (hierarchy level first, then lexicographic IRI ordering for properties without explicit levels) and concatenated with `&` separator
- **Transform List Canonical Format:** Each RegexTransform serialized as `<https://w3id.org/solid-crdt-sync/vocab/idx#RegexTransform>{"pattern":"escaped_pattern","replacement":"escaped_replacement"}` where strings are JSON-escaped, multiple transforms separated by `|`, empty list represented as empty string

**Hash Computation Examples:**
```turtle
# FullIndex for recipes
# Input: "https://schema.org/Recipe|ModuloHashSharding|md5"
# Directory: /indices/recipes/index-full-a1b2c3d4/
# Document: /indices/recipes/index-full-a1b2c3d4/index

# GroupIndexTemplate for shopping entries with single property
# groupingRuleProperties: "https://example.org/vocab/meal#requiredForDate|<https://w3id.org/solid-crdt-sync/vocab/idx#RegexTransform>{\"pattern\":\"^([0-9]{4})-([0-9]{2})-([0-9]{2})$\",\"replacement\":\"${1}-${2}\"}||"
# (format: sourceProperty|transformList_canonical|hierarchyLevel|missingValue - empty missingValue at end)
# Input: "https://example.org/vocab/meal#requiredForDate|<https://w3id.org/solid-crdt-sync/vocab/idx#RegexTransform>{\"pattern\":\"^([0-9]{4})-([0-9]{2})-([0-9]{2})$\",\"replacement\":\"${1}-${2}\"}|||groups/{monthYear}/index|https://example.org/vocab/meal#ShoppingListEntry|ModuloHashSharding|md5"
# Directory: /indices/shopping-entries/index-grouped-e5f6g7h8/
# Document: /indices/shopping-entries/index-grouped-e5f6g7h8/index

# GroupIndexTemplate with single property (GC index example)
# groupingRuleProperties: "https://w3id.org/solid-crdt-sync/vocab/crdt#deletedAt|<https://w3id.org/solid-crdt-sync/vocab/idx#RegexTransform>{\"pattern\":\"^([0-9]{4})-[0-9]{2}-[0-9]{2}$\",\"replacement\":\"${1}\"}||"
# Input: "https://w3id.org/solid-crdt-sync/vocab/crdt#deletedAt|<https://w3id.org/solid-crdt-sync/vocab/idx#RegexTransform>{\"pattern\":\"^([0-9]{4})-[0-9]{2}-[0-9]{2}$\",\"replacement\":\"${1}\"}|||gc/{deletionYear}/index|https://w3id.org/solid-crdt-sync/vocab/sync#ManagedDocument|ModuloHashSharding|md5"
# Directory: /indices/gc/index-grouped-f9g8h7i6/
# Document: /indices/gc/index-grouped-f9g8h7i6/index

# GroupIndexTemplate with multiple properties
# Two properties: rdf:type and schema:keywords
# groupingRuleProperties: "http://www.w3.org/1999/02/22-rdf-syntax-ns#type|||&https://schema.org/keywords|||default"
# (sorted by sourceProperty IRI, joined with &, empty transform lists represented as empty string)
# Input: "http://www.w3.org/1999/02/22-rdf-syntax-ns#type|||&https://schema.org/keywords|||default|groups/{type}-{keyword}/index|https://schema.org/Recipe|ModuloHashSharding|md5"
```

**Automatic Convergence Property:**
Applications with identical structural requirements generate identical index names, enabling automatic collaboration without explicit coordination.

**Discovery-First Bootstrap Flow:**
1. **Discovery:** Query Type Index for existing indices of required type and class
2. **Structural analysis:** Evaluate discovered indices for compatibility  
3. **Join or create:** Add self as reader to compatible index OR create new index with structure-derived name
4. **Collaborative population:** All installations participate in distributed population using populating shards and background processing

**Immutable vs Extendable Properties:**

**Immutable (encoded in name, enforced by `crdt:Immutable` or `crdt:FWW_Register`):**
- Index type (FullIndex vs GroupIndexTemplate)
- Indexed class (`idx:indexesClass`)
- Grouping configuration (`idx:groupedBy` structure)
- Base sharding algorithm (type and hash function, but not shard count)

**Extendable (CRDT-managed, not in name):**
- `idx:indexedProperty` with per-property `idx:readBy` tracking
- Installation reader lists (`idx:readBy` on index level)
- Shard count (auto-scaling based on volume)

**Conflict Escalation:**
When installations attempt to create indices with conflicting immutable properties, the conflict forces automatic creation of differently-named indices, preventing corruption while maintaining functionality.

**Example Coordination Scenarios:**
```turtle
# App A and App B both need FullIndex for recipes with md5
# → Both generate identical name: index-full-a1b2c3d4
# → Automatic sharing through convergent naming

# App C needs GroupIndexTemplate for recipes with weekly grouping  
# → Different structural hash: index-grouped-f9g0h1i2
# → Separate index to avoid incompatible structural conflicts
```

**Performance Impact Management:**
- **Write overhead awareness:** Every additional index increases write operation overhead for all installations
- **Property-level optimization:** Framework automatically removes unused `idx:indexedProperty` entries when last reader is tombstoned (see Section 5.8 for index lifecycle management)
- **Reader list maintenance:** Framework automatically removes tombstoned installations from `idx:readBy` lists, enabling index tombstoning when no active readers remain (see Section 5.8)

#### 5.3.6. Index Population Mechanics

Index population occurs in two scenarios: when creating a new index, or when syncing an existing index that is still in populating state.

**Population Variants Overview:**

The framework uses two different approaches for population based on the index type:

**FullIndex Population:** Works directly on target shards that will be used for normal operations. The `idx:hasPopulatingShard` list contains the same shard names as `idx:hasShard`, enabling unified progress tracking.

**GroupIndexTemplate Population:** Uses temporary coordination shards (`pop-` prefix) to distribute work across installations. These temporary shards coordinate creation of actual GroupIndex instances and are tombstoned when complete.

**Unified Population Process:**

**Index Creation Process:**
1. **Directory scan:** Creating installation recursively lists all resource IRIs from data container and subfolders
2. **Initial structure:** 
   - **For FullIndex:** Create index and target shards with minimal entries (resource IRIs only), list target shards in both `idx:hasShard` and `idx:hasPopulatingShard`
   - **For GroupIndexTemplate:** Create index and temporary populating shards for coordination work
   (See [SHARDING.md](SHARDING.md) for shard count determination details)

**Distributed Processing Algorithm:**
When any installation encounters a populating index during sync:
1. **Work distribution:** Each installation computes `hash(installationIRI + shardIRI)` for each shard in `idx:hasPopulatingShard`
2. **Priority ordering:** Sort shards by hash value (different order per installation)
3. **Sequential processing:** Process shards in priority order until all complete
4. **Collaborative completion:** Multiple installations work simultaneously, CRDT merge resolves conflicts

**Per-Shard Processing:**
1. **Fetch current state:** GET populating shard from Pod
2. **CRDT merge:** Merge with local processing state
3. **Check completeness:** Verify if shard needs processing
4. **Population work:** 
   - **For FullIndex:** Read resources, add `idx:belongsToIndexShard` back-pointers, calculate HLC hashes, populate shard entries
   - **For GroupIndexTemplate:** Read resources, determine group assignments, add `idx:belongsToIndexShard` back-pointers to GroupIndex shards, create GroupIndex instances, populate both populating shard and target group shards
5. **Completion marking:** 
   - **For FullIndex:** Remove shard from `idx:hasPopulatingShard` OR-Set
   - **For GroupIndexTemplate:** Tombstone populating shard with `crdt:deletedAt` AND remove from `idx:hasPopulatingShard` OR-Set
6. **Upload:** PUT updated shard and index to Pod
   - **ETag optimization:** Store ETags from GET responses, use `If-Match` headers on PUT to detect concurrent modifications
   - **On 412 Precondition Failed:** GET current state, perform CRDT merge with local changes, retry PUT with merged result

**State Transition to Active:**

*LWW-Register State Machine for `idx:populationState`:*
1. **Initial State:** Index created with `idx:populationState "populating"`
2. **Completion Detection:** Installation detects `idx:hasPopulatingShard` is empty (all shards completed)
3. **State Update:** Installation attempts `idx:populationState "active"` with current Hybrid Logical Clock
4. **Collaborative Resolution:** Multiple installations may attempt transition simultaneously
   - LWW-Register ensures deterministic convergence to "active" state
   - Hybrid Logical Clock comparison resolves concurrent updates

**Concrete Examples:**

**FullIndex during population:**
```turtle
<FullIndex>
   idx:populationState "populating";
   idx:hasPopulatingShard <shard-mod-md5-2-0-v1_0_0>, <shard-mod-md5-2-1-v1_0_0>;
   # Target shards created with minimal entries (resource IRIs only)
   idx:hasShard <shard-mod-md5-2-0-v1_0_0>, <shard-mod-md5-2-1-v1_0_0> .
```

**GroupIndexTemplate during population:**
```turtle
<GroupIndexTemplate>
   idx:populationState "populating";
   # Temporary coordination shards for distributed work
   idx:hasPopulatingShard <pop-mod-md5-4-0-v1_0_0>, <pop-mod-md5-4-1-v1_0_0>, 
                          <pop-mod-md5-4-2-v1_0_0>, <pop-mod-md5-4-3-v1_0_0> .
```

#### 5.3.7. Installation Index Management and Scalability

**Installation Management Strategy:** Within the framework's design constraints of 2-100 installations, installation management uses a dedicated **Framework Installation Index** combined with periodic **Management Phase** operations (detailed in Section 6.2).

**Framework Installation Index:**
Rather than expensive Type Index container scanning, the framework maintains a dedicated installation index that provides efficient batch access to installation states:

```turtle
# At /indices/framework/installations-index-${hash}/index  
<> a idx:FullIndex;
   sync:isGovernedBy mappings:index-v1;
   idx:indexesClass crdt:ClientInstallation;
   idx:indexedProperty [
     idx:trackedProperty crdt:lastActiveAt;        # For dormancy detection
     idx:readBy <installation-1>, <installation-2>
   ], [
     idx:trackedProperty crdt:maxInactivityPeriod; # For cleanup thresholds
     idx:readBy <installation-1>, <installation-2>  
   ] .
```

**Operational Benefits:**
- **Efficient reader list management**: Management phase can batch-validate installation states without individual Pod requests
- **Collaborative dormancy detection**: Multiple installations can safely coordinate cleanup through CRDT operations
- **Scalable at target range**: Direct OR-Set management of `idx:readBy` lists works efficiently for 2-100 installations
- **Framework consistency**: Uses same indexing patterns as user data

**Management Phase Integration:** Installation lifecycle operations (dormancy detection, reader list cleanup, tombstone processing) are handled through periodic Management Phase operations rather than during every sync. See Section 6.2 for detailed algorithms and coordination mechanisms.

**Beyond Design Scale:** For scenarios exceeding 100 installations, different architectural patterns might be more appropriate than extending this framework.

#### 5.3.8. Index Structure Examples

The following examples demonstrate concrete RDF structures for different types of indices, showing how the indexing architecture works in practice with real data.

**Example 1: A `GroupIndexTemplate` at `https://alice.podprovider.org/indices/shopping-entries/index-grouped-e5f6g7h8/index`**
This resource is the "rulebook" for all shopping list entry groups in our meal planning application. The name hash is derived from SHA256 of the canonical transform format shown in section 5.3.5. Note that it has no `idx:indexedProperty` because shopping entries are typically loaded in full groups, requiring only Hybrid Logical Clock hashes for change detection.

```turtle
@prefix sync: <https://w3id.org/solid-crdt-sync/vocab/sync#> .
@prefix idx: <https://w3id.org/solid-crdt-sync/vocab/idx#> .
@prefix schema: <https://schema.org/> .
@prefix mappings: <https://w3id.org/solid-crdt-sync/mappings/> .
@prefix meal: <https://example.org/vocab/meal#> .

# Note: The mappings: namespace contains CRDT merge contracts for specification components
# such as group-index-template-v1, group-index-v1, shard-v1, full-index-v1

<> a idx:GroupIndexTemplate;
   sync:isGovernedBy mappings:index-v1;
   idx:indexesClass meal:ShoppingListEntry;
   # No idx:indexedProperty needed - groups are loaded fully
   # A default sharding algorithm for all group indices created under this rule.
   # Resources within each group are assigned to shards using: hash(resourceIRI) % numberOfShards
   idx:shardingAlgorithm [
     a idx:ModuloHashSharding;
     idx:hashAlgorithm "md5";  # Framework standard: md5 provides fast, consistent hashing
     idx:numberOfShards 4
   ] ;
   sync:isGovernedBy mappings:group-index-template-v1;

   # The declarative rule for how to assign items to group indices.
   idx:groupedBy [
     a idx:GroupingRule;
     idx:property [
       a idx:GroupingRuleProperty;
       idx:sourceProperty meal:requiredForDate;
       idx:transform (
         [
           a idx:RegexTransform;
           idx:pattern "^([0-9]{4})-([0-9]{2})-([0-9]{2})$";
           idx:replacement "${1}-${2}"
         ]
       ) .
     ];
     # No groupTemplate - paths generated deterministically as: groups/{yyyy-MM}/index
   ].
```

**Example 2: A `GroupIndex` document at `https://alice.podprovider.org/indices/shopping-entries/index-grouped-e5f6g7h8/groups/2024-08/index`**
This is a concrete index for shopping list entries from August 2024 meal plans.

```turtle
@prefix sync: <https://w3id.org/solid-crdt-sync/vocab/sync#> .
@prefix idx: <https://w3id.org/solid-crdt-sync/vocab/idx#> .

<> a idx:GroupIndex;
   sync:isGovernedBy mappings:index-v1;
   # Back-link to the rulebook.
   idx:basedOn <../../index-grouped-e5f6g7h8/index>;
   # Inherits configuration from GroupIndexTemplate:
   # - Sharding algorithm (ModuloHashSharding with md5, 4 shards)
   # - Indexed properties (none defined, so minimal entries only)
   # - CRDT merge contract (mappings:index-v1)
   # Since the template has no idx:indexedProperty defined, this group's shards
   # will contain only resource IRIs and Hybrid Logical Clock hashes (no header data).
   # It has its own list of active shards, which are sibling documents.
   idx:hasShard <shard-mod-md5-4-0-v1_0_0>, <shard-mod-md5-4-1-v1_0_0>, 
                <shard-mod-md5-4-2-v1_0_0>, <shard-mod-md5-4-3-v1_0_0> .
```

**Example 3: A Shard Document at `https://alice.podprovider.org/indices/shopping-entries/index-grouped-e5f6g7h8/groups/2024-08/shard-mod-md5-4-0-v1_0_0`**
This document contains entries pointing to shopping list data resources from August 2024. Since shopping entries are typically loaded in full groups, this index contains minimal entries (only resource IRI and Hybrid Logical Clock hash, no header properties).

```turtle
@prefix sync: <https://w3id.org/solid-crdt-sync/vocab/sync#> .
@prefix idx: <https://w3id.org/solid-crdt-sync/vocab/idx#> .
@prefix crdt: <https://w3id.org/solid-crdt-sync/vocab/crdt-mechanics#> .
@prefix mappings: <https://w3id.org/solid-crdt-sync/mappings/> .

<> a idx:Shard;
   sync:isGovernedBy mappings:shard-v1;
   idx:isShardOf <index>; # Back-link to its GroupIndex document
   # Note: Shard entries do not require explicit typing (a idx:ShardEntry) for space efficiency.
   # Instead, idx:resource is marked as identifying at the predicate level in mappings:shard-v1.
   idx:containsEntry [
     idx:resource <../../../../data/shopping-entries/created/2024/08/weekly-shopping-001>;
     crdt:clockHash "xxh64:abcdef1234567890"
   ],
   [
     idx:resource <../../../../data/shopping-entries/created/2024/08/weekly-shopping-002>;
     crdt:clockHash "xxh64:fedcba9876543210"
   ].
```

**Example 4: A Recipe Index for OnDemand Sync at `https://alice.podprovider.org/indices/recipes/index-full-a1b2c3d4/index`**
This is a `FullIndex` for Alice's recipe collection, configured for OnDemand synchronization to enable recipe browsing. The name hash is derived from SHA256(https://schema.org/Recipe|ModuloHashSharding|md5).

```turtle
@prefix sync: <https://w3id.org/solid-crdt-sync/vocab/sync#> .
@prefix idx: <https://w3id.org/solid-crdt-sync/vocab/idx#> .
@prefix schema: <https://schema.org/> .
@prefix mappings: <https://w3id.org/solid-crdt-sync/mappings/> .

<> a idx:FullIndex;
   sync:isGovernedBy mappings:index-v1;
   idx:indexesClass schema:Recipe;
   # Include properties needed for recipe browsing UI
   idx:indexedProperty [
     a idx:IndexedProperty;
     idx:trackedProperty schema:name;
     idx:readBy <installation-1>, <installation-2>
   ], [
     a idx:IndexedProperty;
     idx:trackedProperty schema:keywords;
     idx:readBy <installation-1>, <installation-2>
   ], [
     a idx:IndexedProperty;
     idx:trackedProperty schema:totalTime;
     idx:readBy <installation-1>, <installation-2>
   ];
   # Default sharding for the recipe collection
   # Resources are assigned to shards using: hash(resourceIRI) % numberOfShards
   idx:shardingAlgorithm [
     a idx:ModuloHashSharding;
     idx:hashAlgorithm "md5";
     idx:numberOfShards 2
   ];
   sync:isGovernedBy mappings:full-index-v1;
   # List of active shards containing recipe entries
   idx:hasShard <shard-mod-md5-2-0-v1_0_0>, <shard-mod-md5-2-1-v1_0_0> .
```

**Example 5: A Recipe Index Shard for OnDemand Sync at `https://alice.podprovider.org/indices/recipes/index-full-a1b2c3d4/shard-mod-md5-2-0-v1_0_0`**
This document contains entries for recipe resources. Since recipes are used with OnDemand sync, the index includes header properties (schema:name, schema:keywords, etc.) as specified in the FullIndex's `idx:indexedProperty` list to support browsing without loading full recipe data.

```turtle
@prefix sync: <https://w3id.org/solid-crdt-sync/vocab/sync#> .
@prefix idx: <https://w3id.org/solid-crdt-sync/vocab/idx#> .
@prefix crdt: <https://w3id.org/solid-crdt-sync/vocab/crdt-mechanics#> .
@prefix schema: <https://schema.org/> .
@prefix mappings: <https://w3id.org/solid-crdt-sync/mappings/> .

<> a idx:Shard;
   sync:isGovernedBy mappings:shard-v1;
   idx:isShardOf <index>;
   idx:containsEntry [
     idx:resource <../../data/recipes/tomato-basil-soup>;
     schema:name "Tomato Basil Soup";
     schema:keywords "vegan", "soup";
     schema:totalTime "PT30M";
     crdt:clockHash "xxh64:abcdef1234567890"
   ],
   [
     idx:resource <../../data/recipes/pasta-carbonara>;
     schema:name "Pasta Carbonara";
     schema:keywords "pasta", "italian";
     schema:totalTime "PT20M";
     crdt:clockHash "xxh64:fedcba9876543210"
   ].
```

### 5.4. Layer 4: The Sync Strategy

This is the client-side layer where the application developer configures how to synchronize data. The CRDT implementation balances **discovery** (finding existing Pod configuration) with **developer intent** (application requirements). Developers declare their preferred sync approach, and the implementation either uses discovered compatible indices or creates new ones as needed.

#### 5.4.1. Decision 1: Index Structure

This decision determines how data is organized and indexed in the Pod.

**FullIndex (Monolithic):**
*   Single index covering entire dataset
*   Good for bounded, searchable collections
*   Examples: Personal recipes, document library, contact list

**GroupIndexTemplate (Grouped):**
*   Data split into logical groups via GroupingRule  
*   Good for unbounded or naturally-grouped data
*   Examples: Shopping entries by month, financial transactions by year

**Implementation Note:** The framework automatically handles index discovery and creation through structure-derived naming (see Section 4.3.4 for technical details). Developers simply declare their data organization needs, and the implementation manages the underlying index infrastructure.

#### 5.4.2. Decision 2: Sync Timing

This decision determines when and how much data gets loaded from the Pod.

**Full Data Sync:**
*   Downloads index AND immediately fetches all resource data for the selected indices/groups
*   Good for small datasets that are frequently accessed
*   Examples: User settings, small contact lists, preferences

**On-Demand Sync (Index-Only):**
*   Downloads only index initially (provides headers/metadata)
*   Fetches full resource data only when explicitly requested  
*   Good for large datasets or browse-then-load workflows
*   Examples: Large recipe collections, document libraries, photo albums

#### 5.4.3. Common Strategies

The named sync strategies combine the two decisions above:

| Strategy | Index Structure | Sync Timing | Use Case |
|----------|----------------|-------------|----------|
| **`FullSync`** | FullIndex | Full Data Sync | Small, frequently-accessed datasets |
| **`GroupedSync`** | GroupIndexTemplate | Full Data Sync | Time-series data with active groups |
| **`OnDemandSync`** | FullIndex OR GroupIndexTemplate | On-Demand Sync | Large collections, browse-then-load |

**Examples:**
*   **FullSync:** User preferences, small contact lists → FullIndex + immediate data loading
*   **GroupedSync:** Shopping entries, activity logs → GroupIndexTemplate + immediate data for subscribed groups  
*   **OnDemandSync:** Recipe collections, document libraries → Any index + headers-only until requested

For detailed performance analysis, benchmarks, and optimization guidance for each sync strategy, see [PERFORMANCE.md](PERFORMANCE.md).
