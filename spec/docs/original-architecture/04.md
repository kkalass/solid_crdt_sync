## 4. Foundations

Having established the overall architectural approach, this section examines the technical foundations that make reliable CRDT synchronization possible in the RDF/Solid ecosystem. We start with CRDT fundamentals (4.1), then address the critical RDF identity challenges that shaped our approach (4.2), followed by integration and lifecycle mechanisms (4.3-4.6).

### 4.1. CRDT Fundamentals

Before examining RDF-specific challenges, it's essential to understand the core CRDT concepts that underpin this architecture. These data structures enable conflict-free merging of distributed data without requiring coordination between clients.

#### 4.1.1. Core CRDT Types

**LWW-Register (Last-Writer-Wins Register):**
- Used for single-value properties where the most recent write should win
- Examples: Recipe name, creation timestamp, status field
- Conflict resolution: Compare timestamps, newer value wins
- **Multi-value behavior:** Treats complete value set atomically - most recent set wins, replaces all previous values
- Compatible with any object type (IRIs, literals, blank nodes)

**FWW-Register (First-Writer-Wins Register):**
- Used for immutable properties where "first to set wins" semantics are desired
- Examples: Resource identifiers, permanent classifications, initial configurations
- Conflict resolution: Compare timestamps, first write wins, subsequent writes ignored
- **Multi-value behavior:** Preserves the first complete value set, ignores subsequent modifications
- Provides graceful degradation alternative to Immutable's strict merge failure

**OR-Set (Observed-Remove Set):**
- Used for multi-value properties where additions and removals must be tracked separately
- Examples: Recipe keywords, ingredient lists, tag collections
- Conflict resolution: Union of all additions, minus explicitly removed items
- Requires stable object identity for tombstone matching across documents

**2P-Set (Two-Phase Set):**
- Add-only sets with tombstone-based removal (elements can be added and removed, but not re-added)
- Used for properties where re-addition after removal should be prevented
- Requires stable object identity for tombstone operations

**Immutable:**
- Framework-specific constraint (not a traditional CRDT algorithm)
- Used for properties that must never change after creation with strict enforcement
- Examples: Resource creation timestamps, installation identifiers, structural configurations
- **Multi-value behavior:** Complete value set treated as immutable - any modification causes merge failure
- Conflict resolution: Merge fails if different values encountered, forces resource versioning
- **Key distinction from FWW-Register:** Immutable causes sync failure for conflicts, FWW-Register silently ignores them

**Hybrid Logical Clock (HLC):**
- Combines logical causality tracking with physical wall-clock timestamps
- Provides tamper-resistant causality determination and intuitive tie-breaking
- Each document maintains a clock that advances with each change
- Enables "newer wins" semantics while protecting against clock manipulation

**Framework Extensibility:** The architecture is designed to support additional CRDT algorithms beyond this initial set. The core infrastructure (Hybrid Logical Clocks, blank node identification, merge contracts) provides the foundation for extending to counters, sequences, and other algorithm families, though complex algorithms may require enhancements to the identification or merge rule systems.

#### 4.1.2. State-Based vs Operation-Based CRDTs

This framework uses **state-based CRDTs** rather than operation-based approaches:

**State-Based Approach (This Framework):**
- Synchronizes complete document state between replicas
- Compatible with passive storage backends like Solid Pods
- Merge function operates on entire document states
- Higher bandwidth but simpler implementation

**Operation-Based Approach (Alternative):**
- Synchronizes individual operations/changes between replicas
- Requires active coordination and reliable message delivery
- Lower bandwidth but requires more complex infrastructure
- Examples: Yjs, Automerge operation streams

#### 4.1.3. Property-Level CRDT Integration

The framework applies these CRDT types at the **property level** within RDF resources:
- Each property in a resource is governed by a specific CRDT type
- Merge contracts (`sync:` vocabulary) declaratively link properties to CRDT algorithms
- Document-level Hybrid Logical Clocks coordinate the overall merge process
- The result is deterministic, conflict-free merging of arbitrary RDF data

#### 4.1.4. Multi-Value Property Examples

Understanding how different CRDT types handle multi-value properties is crucial for correct usage:

**Immutable Multi-Value Example (Garbage Collection Index):**
```turtle
# Template defines multiple document types - this complete set is immutable
idx:indexesClass sync:ManagedDocument, idx:FullIndex, idx:GroupIndex, idx:GroupIndexTemplate, idx:Shard;
```
- **Merge behavior:** If any installation attempts to change this set (add/remove types), merge fails
- **Use case:** Structural configurations that must remain consistent across all installations
- **Error handling:** Forces resource versioning or manual intervention

**FWW-Register Multi-Value Example (Installation Configuration):**
```turtle
# First installation to set supported features wins
app:supportedFeatures "recipes", "meal-planning", "shopping-lists";
```
- **Merge behavior:** First complete set wins, subsequent modifications ignored
- **Use case:** Initial configurations where "first to configure wins" behavior is desired  
- **Error handling:** Graceful degradation, no sync failure

**LWW-Register Multi-Value Example (Accidental Usage):**
```turtle
# If mistakenly used for multi-value property
recipe:keywords "quick", "easy", "vegetarian";  # Alice's version
recipe:keywords "healthy", "dinner";           # Bob's later version  
# Result: Bob's complete set wins - Alice's keywords completely replaced
```
- **Merge behavior:** Most recent complete set wins, all previous values discarded
- **Use case:** Generally incorrect for multi-value properties - should use OR-Set instead
- **Error handling:** No sync failure, but likely unintended data loss

**Key Decision Points:** 
- Choose **Immutable** when strict consistency is critical and conflicts indicate serious configuration errors
- Choose **FWW-Register** when graceful degradation and "first wins" semantics are desired  
- Choose **LWW-Register** only for truly single-value properties - avoid for multi-value to prevent data loss
- Choose **OR-Set** for collaborative multi-value properties where individual additions/removals matter

### 4.2. Core RDF Challenges

CRDTs require stable object identity for operations like OR-Set tombstone matching and 2P-Set removal tracking. This creates a fundamental challenge with RDF blank nodes, whose document-scoped identifiers cannot be reliably matched across different document instances. For RDF-knowledgeable readers, this section addresses the "obvious" question: how can CRDT operations work reliably with RDF's semantic model? The following sections explain the framework's context-based identification solution and its implications for merge contract design.


#### 4.2.1. Three-Level Merging Hierarchy

**Three Distinct Operations:** The framework performs merging operations at three different levels, with document-level decisions handling special cases and tombstoning:

1. **Document-Level Merging:** Handles special cases where document-level decisions override resource-level merging:
   - **Tombstoning decisions:** `max(crdt:deletedAt) > max(crdt:createdAt)` empties all semantic content
   - **Fallback behavior:** When merge contracts are incompatible/unknown, entire document wins via `crdt:LWW_Register`

2. **Resource Merging:** For normal cases, combine all properties belonging to the same identified resource across documents. This is resource-scoped processing - each identified resource gets merged independently based on its own properties, regardless of how many other resources reference it.

3. **Property Merging:** Within each identified resource, apply CRDT rules (LWW-Register, OR-Set, etc.) to merge individual property values according to the resource's merge contract.

**Processing Flow:** 
- **First check document-level conditions** (tombstoning, compatibility, identifiability)
- **If document-level merging applies:** Use atomic document handling
- **Otherwise:** Proceed with normal resource-level and property-level merging

**Impact on Each Operation:** The blank node identity problem affects the resource and property merging operations differently:

**Resource Merging Impact:** When non-identifiable resources appear as subjects, we cannot determine if `_:b1` in document A corresponds to `_:b1` in document B, even if they have identical properties. The blank node labels are arbitrary serialization decisions that only have meaning within a single document instance by RDF definition. Therefore, we cannot merge their properties - each document's version must be treated atomically.

**Property Merging Impact:** When non-identifiable resources appear as object values, we cannot determine equality for CRDT operations that depend on identity. For example, OR-Set tombstones cannot match their target objects across documents because `[rdfs:label "homemade"]` in a tombstone cannot be reliably compared to `[rdfs:label "homemade"]` in the live data.

#### 4.2.2. The Blank Node Challenge

**The Fundamental RDF Constraint:** RDF blank nodes are document-instance-scoped by definition - their identifiers (like `_:b1`) only have meaning within a single document instance. The RDF specification allows different implementations to assign blank node labels arbitrarily, so the same semantic content might be labeled `_:b1` in one instance and `_:genid123` in another. When merging two document instances (e.g., local `recipe-123.ttl` and remote `recipe-123.ttl`), we cannot determine if `_:b1` in the local instance corresponds to `_:b1` in the remote instance - even if the labels match, this must be treated as incidental coincidence rather than semantic equivalence.

**Why This Matters for CRDTs:** Many CRDT operations require stable identity to function correctly:
- **OR-Set and 2P-Set** tombstones must match their target objects across documents
- **Sequence CRDTs** need to maintain consistent element ordering
- **Merge algorithms** must determine which resources represent the same entity

**The Core Problem:** Without stable identity, we cannot reliably merge RDF graphs containing blank nodes, leading to data inconsistency and CRDT convergence failures.

#### 4.2.3. The Solution: Context-Based Identification

**The Key Insight:** Some blank nodes can become identifiable through the combination of context + properties, enabling safe CRDT operations within specific scopes.

**The Mechanism:** Mapping documents can declare that specific properties serve as identifiers for blank nodes using `mc:isIdentifying true` boolean flags within mapping rules (part of our `mc:` vocabulary for merge contracts). This creates stable identity within a known context scope.

**The Pattern:** `(context, identifying properties)` creates sufficient identity for safe merging within that scope. The context is the identifier of the subject containing the blank node, and identifying properties are the values of predicates with `mc:isIdentifying true` flags in their rules. With compound keys, the pattern becomes `(context, property1=value1, property2=value2, ...)`.

**Recursive Context Building:** Context identifiers can be built recursively - an identified blank node can serve as context for nested blank nodes:
- **Base case:** IRI-identified resource (e.g., `<https://alice.podprovider.org/data/recipes/tomato-soup#it>`)  
- **Recursive case:** Previously identified blank node (e.g., `(<https://alice.../recipes/tomato-soup#it>, installationId=<https://alice.../installation-123>)` identifies a clock entry)
- **Nested example:** `((<https://alice.../recipes/tomato-soup#it>, installationId=<https://alice.../installation-123>), subProperty=value)` could identify a blank node within a clock entry

For example, Hybrid Logical Clock entries are identified by `(document_IRI, crdt:installationId=<full_installation_IRI>)`, where `document_IRI` is the full document IRI context and `crdt:installationId=<full_installation_IRI>` are the identifying properties.

**Implementation Details:** For detailed mapping syntax, complex identification scenarios, and implementation patterns, see [CRDT-SPECIFICATION.md section 4](CRDT-SPECIFICATION.md#4-crdt-mapping-validation). 

#### 4.2.4. Resource Identity Taxonomy

**The Critical Three-Way Distinction:** Resources fall into three categories based on their identity characteristics:

**1. IRI-Identified Resources** (globally unique):
- **Example:** `<https://alice.podprovider.org/data/recipes/tomato-soup#it>`
- **Identity:** Globally unique, stable identifiers
- **CRDT Compatibility:** Safe for all CRDT operations

**2. Context-Identified Blank Nodes** (unique within context):
- **Example:** `(<https://alice.../recipes/tomato-soup#it>, installationId=<https://alice.../installation-123>)`
- **Identity:** Unique within specific context through identifying properties
- **CRDT Compatibility:** Safe for all CRDT operations when properly identified

**3. Non-Identifiable Resources** (no stable identity):
- **Example:** `[]` with no identifying properties or non-identifiable parent subject
- **Identity:** Document-scoped identifiers without stable identification patterns
- **CRDT Compatibility:** Limited to atomic operations (LWW-Register only)

**Determining Identifiability:** A blank node becomes identifiable when:
1. A mapping rule declares some predicate as identifying (`mc:isIdentifying true`)  
2. The blank node has that identifying predicate as one of its properties
3. The subject that references the blank node is itself identifiable (IRI or previously identified blank node)

#### 4.2.5. CRDT Compatibility Rules

**The Critical Constraint:** Identity-dependent CRDTs (OR-Set, 2P-Set) require stable object identity to match tombstones with their targets across documents. Non-identifiable blank nodes cause these operations to fail.

**Compatibility Matrix:**
- **OR-Set, 2P-Set:** Can ONLY be used when object values are identifiable (IRIs, literals, or context-identified blank nodes)
- **LWW-Register:** Can work with non-identifiable object values (treats them atomically)

**Error Prevention:** Invalid mappings (e.g., OR-Set on non-identifiable blank nodes) must be detected during merge contract validation. Resources with invalid mappings are rejected at the resource level, allowing other resources of the same type to continue syncing.

**Detailed Examples:** For comprehensive examples of identification failures, structural equality problems, and solution patterns, see [CRDT-SPECIFICATION.md section 4](CRDT-SPECIFICATION.md#4-crdt-mapping-validation).

#### 4.2.6. Development Implications

- **Data Modeling:** Prefer IRIs over blank nodes when identity-dependent CRDT operations are needed
- **Mapping Design:** Understand identifiability requirements for each CRDT type and use `mc:isIdentifying` appropriately
- **Validation:** Implement mapping validation to prevent invalid configurations
- **Performance:** Flat resource processing enables parallel merging optimizations

#### 4.2.7. Implementation Consistency Checks

**Recommended Practice:** Implementing libraries should perform consistency checks during mapping generation or validation, particularly when mappings are derived from code annotations:

- **Blank Node Identification:** Verify that all blank nodes used with identity-dependent CRDTs (OR-Set, 2P-Set) have appropriate `mc:isIdentifying` declarations
- **Mapping Completeness:** Ensure all properties of a class have corresponding merge rules in the mapping contract
- **CRDT Compatibility:** Validate that each property's declared CRDT type is compatible with its object types (see section 4.2 in CRDT-SPECIFICATION.md)
- **Multi-Value Semantics:** Verify understanding of how each CRDT type handles multi-value properties (LWW-Register = atomic set replacement, Immutable = complete set immutable, FWW-Register = first complete set wins, OR-Set = collaborative set operations)
- **Generator Feedback:** When using code generation from annotations, provide clear error messages identifying specific properties or patterns that need correction

**Example Generator Check:**
```dart
// Recipe class annotations
@LWWRegister() // ✅ Valid - works with any object type
String recipeName;

@ORSet() // ✅ Valid because Ingredient class declares identifying properties
List<Ingredient> ingredients; // Generator validates that Ingredient mapping exists

// Ingredient class annotations (separate from Recipe)
class Ingredient {
  @LWWRegister() 
  @IsIdentifying() // ✅ Declares this property as identifying
  String name;
  
  @LWWRegister()
  @IsIdentifying() // ✅ Compound key with name
  String unit;
  
  @LWWRegister() // ✅ Regular property, not identifying
  double amount;
}

// Generator produces mapping:
// mc:rule [ mc:predicate recipe:name; algo:mergeWith algo:LWW_Register; mc:isIdentifying true ],
//           [ mc:predicate recipe:unit; algo:mergeWith algo:LWW_Register; mc:isIdentifying true ],
//           [ mc:predicate recipe:amount; algo:mergeWith algo:LWW_Register ]
```

This constraint fundamentally shapes merge contract design, mapping validation, and the scope of supported CRDT operations.

### 4.3. Resource/Document Abstraction

Developers want to work with individual recipe properties like `schema:name` and `schema:ingredients`, but efficient sync requires handling entire documents as atomic units. This section explains how the framework solves both needs through coordinated abstraction levels.

#### 4.3.1. The Problem: Two Different Mental Models

**What Developers Want to Work With:**
```turtle
# Individual recipe properties - feels natural for app development
<https://alice.podprovider.org/data/recipes/tomato-soup#it> 
    schema:name "Tomato Soup" ;
    schema:ingredients "tomatoes, basil" ;
    schema:prepTime "PT30M" .
```

**What Efficient Sync Requires:**

*Document: `/data/recipes/tomato-soup`*
```turtle
# Complete document with sync metadata - efficient for protocol operations
<https://alice.podprovider.org/data/recipes/tomato-soup> 
    a sync:ManagedDocument ;
    sync:managedResourceType schema:Recipe ;  # Enables resource-type-specific retention policies
    crdt:hasClockEntry [
        crdt:installationId <https://alice.podprovider.org/installations/mobile-recipe-app-2024-08-19-xyz> ;
        crdt:logicalTime "15"^^xsd:long ;
        crdt:physicalTime "1693824600000"^^xsd:long
    ] ;
    sync:isGovernedBy <https://alice.podprovider.org/mappings/recipes-v1> ;
    crdt:clockHash "abc123def456" .

<https://alice.podprovider.org/data/recipes/tomato-soup#it> 
    schema:name "Tomato Soup" ;
    schema:ingredients "tomatoes, basil" ;
    schema:prepTime "PT30M" .
```

The framework needs to support both perspectives simultaneously.

#### 4.3.2. The Solution: Dual Abstraction Levels

**Core Rule:** *When a resource uses a fragment identifier (like `#it`), sync/merge control operates on the entire document, while resource content and indexing operate on the specific resource.*

This creates two coordinated abstraction levels:

**Developer/Application Perspective (Resource-Oriented):**
- Work with resource identities: `https://alice.podprovider.org/data/recipes/tomato-soup#it`
- Receive resource properties for local storage and application logic
- Update individual properties: change just the `schema:prepTime`
- APIs handle resource-level operations and individual property values

**Framework/Sync Perspective (Document-Oriented):**
- Track changes at document level using Hybrid Logical Clock hashes
- Merge conflicts by comparing entire document states, then resolving property-by-property
- Synchronize complete documents as atomic units for consistency
- Handle deletion as all-or-nothing document cleanup

#### 4.3.3. Document-Level Sync with Resource-Level Access

The framework maintains the dual abstraction by tracking changes at the document level while providing access to individual resources:

*Document: `/data/recipes/tomato-soup`*
```turtle
# Document-level change tracking enables efficient sync
<https://alice.podprovider.org/data/recipes/tomato-soup> 
    a sync:ManagedDocument ;
    sync:managedResourceType schema:Recipe ;
    crdt:clockHash "abc123def456" ;  # Single hash covers entire document
    crdt:hasClockEntry [...] ;
    sync:isGovernedBy <mappings> .

# Resource-level content for application use
<https://alice.podprovider.org/data/recipes/tomato-soup#it> 
    schema:name "Tomato Soup" ;
    schema:ingredients "tomatoes, basil" ;
    schema:prepTime "PT30M" .
```

**Conflict Resolution:**
When Alice and Bob edit the same recipe simultaneously, the framework merges at the document level while preserving individual resource properties:

*Merged Document: `/data/recipes/tomato-soup`*
```turtle
# Result: Both changes preserved through property-level conflict resolution
<https://alice.podprovider.org/data/recipes/tomato-soup> 
    a sync:ManagedDocument ;
    sync:managedResourceType schema:Recipe ;
    crdt:clockHash "def789ghi012" ;      # Updated hash reflects merged state
    crdt:hasClockEntry [
        crdt:installationId <https://alice.podprovider.org/installations/mobile-recipe-app-2024-08-19-xyz> ;
        crdt:logicalTime "16"^^xsd:long
    ], [
        crdt:installationId <https://bob.podprovider.org/installations/desktop-recipe-app-2024-08-15-abc> ;
        crdt:logicalTime "15"^^xsd:long
    ] ;
    sync:isGovernedBy <https://alice.podprovider.org/mappings/recipes-v1> .

<https://alice.podprovider.org/data/recipes/tomato-soup#it> 
    schema:name "Spicy Tomato Soup" ;    # Alice's change (higher logical time)
    schema:ingredients "tomatoes, basil" ; # Unchanged property preserved
    schema:prepTime "PT45M" .            # Bob's change (preserved)
```

#### 4.3.4. Benefits of This Approach

**For Developers:**
- Work with standard resource-oriented RDF concepts
- Receive individual resource data for local storage and application logic
- Type registrations use familiar semantic types (`schema:Recipe`)

**For Sync Efficiency:**
- Document-level change detection minimizes network overhead
- Atomic document synchronization prevents partial update inconsistencies
- Single document merge resolves all property conflicts together

**For System Consistency:**
- All changes to resources within a document are synchronized together
- Deletion operates cleanly on complete documents with retention policies
- Fragment resources automatically inherit document-level sync behavior

#### 4.3.5. Implementation Requirements

**Mandatory Document Properties:**
Framework libraries **MUST** include the following properties when creating `sync:ManagedDocument` instances:

- **`foaf:primaryTopic`**: MUST identify the primary resource within the document (typically `<#it>`)
- **`crdt:createdAt`**: MUST be set to document creation timestamp to enable zombie deletion protection
- **`sync:managedResourceType`**: MUST be set to the `rdf:type` of the `foaf:primaryTopic` resource
  - **Purpose**: Enables efficient garbage collection, retention policy lookup, and prevents zombie deletion problems during document recreation
  - **Requirement**: The `sync:managedResourceType` value MUST equal the primary resource type (e.g., `schema:Recipe` for recipe documents)

```turtle
# REQUIRED: All mandatory properties must be present
<https://alice.podprovider.org/data/recipes/tomato-soup> 
    a sync:ManagedDocument ;
    sync:managedResourceType schema:Recipe ;  # MUST match #it rdf:type
    crdt:createdAt "2024-08-15T10:30:00Z"^^xsd:dateTime ;  # MUST be present
    foaf:primaryTopic <#it> .

<https://alice.podprovider.org/data/recipes/tomato-soup#it>
    a schema:Recipe ;  # Must match sync:managedResourceType above
    schema:name "Tomato Soup" .
```

This requirement ensures consistent resource type tracking across Type Index registrations, document metadata, and garbage collection operations.

### 4.4. Solid Discovery Integration

CRDT-managed resources contain synchronization metadata and follow structural conventions that traditional RDF applications don't understand, creating a risk of data corruption. This section describes how the architecture solves this problem through discovery isolation.

CRDT-enabled applications use a modified Solid discovery approach that provides controlled access to managed resources while protecting them from incompatible applications. This isolation strategy prevents data corruption while maintaining standard Solid discoverability principles.

#### 4.4.1. Discovery Isolation Strategy

**The Challenge:** Traditional Solid discovery would expose CRDT-managed data to all applications, risking corruption by applications that don't understand CRDT metadata or Hybrid Logical Clocks.

**The Solution:** CRDT-managed resources are registered under `sync:ManagedDocument` in the Type Index rather than their semantic types (e.g., `schema:Recipe`). The semantic type is preserved via `sync:managedResourceType` property.

**Discovery Behavior:**
- **CRDT-enabled apps:** Query for `sync:ManagedDocument` where `sync:managedResourceType schema:Recipe` → Find managed resources
- **Traditional apps:** Query for `schema:Recipe` → Find nothing (managed data invisible)
- **Legacy data:** Remains discoverable through traditional registrations until explicitly migrated

This creates clean separation: compatible applications collaborate safely on managed data, while traditional apps work with unmanaged data, preventing cross-contamination.

#### 4.4.2. Managed Resource Discovery Protocol

1. **Standard Discovery:** Follow WebID → Profile Document → Public Type Index ([Type Index](https://github.com/solid/type-indexes)):

**Note:** This framework currently uses only the **Public Type Index** for discoverability. This design choice enables inter-application collaboration and resource sharing but means all CRDT-managed resources are discoverable by other applications. See [FUTURE-TOPICS.md](FUTURE-TOPICS.md) for planned Private Type Index support.

```turtle
# In Profile Document at https://alice.podprovider.org/profile/card#me
@prefix solid: <http://www.w3.org/ns/solid/terms#> .

<#me> solid:publicTypeIndex </settings/publicTypeIndex.ttl> .
```

2. **Framework Resource Resolution:** From the Type Index, resolve `sync:ManagedDocument` registrations to data containers:

```turtle
# In Public Type Index at https://alice.podprovider.org/settings/publicTypeIndex.ttl
@prefix sync: <https://w3id.org/solid-crdt-sync/vocab/sync#> .
@prefix solid: <http://www.w3.org/ns/solid/terms#> .
@prefix schema: <https://schema.org/> .
@prefix meal: <https://example.org/vocab/meal#> .

<> a solid:TypeIndex;
   solid:hasRegistration [
      a solid:TypeRegistration;
      solid:forClass sync:ManagedDocument;
      sync:managedResourceType schema:Recipe;
      solid:instanceContainer <../data/recipes/>
   ], [
      a solid:TypeRegistration;
      solid:forClass sync:ManagedDocument;
      sync:managedResourceType meal:ShoppingListEntry;
      solid:instanceContainer <../data/shopping-entries/>
   ] .
```

3. **Specification Type Resolution:** Applications also register specification-defined types (indices and client installations) in the Type Index using the same mechanism:

```turtle
# Also in Public Type Index at https://alice.podprovider.org/settings/publicTypeIndex.ttl
@prefix idx: <https://w3id.org/solid-crdt-sync/vocab/idx#> .
@prefix crdt: <https://w3id.org/solid-crdt-sync/vocab/crdt-mechanics#> .

<> solid:hasRegistration [
      a solid:TypeRegistration;
      solid:forClass idx:FullIndex;
      idx:indexesClass schema:Recipe
      solid:instanceContainer <../indices/recipes/>;
   ], [
      a solid:TypeRegistration;
      solid:forClass idx:GroupIndexTemplate;
      idx:indexesClass meal:ShoppingListEntry
      solid:instanceContainer <../indices/shopping-entries/>;
   ], [
      a solid:TypeRegistration;
      solid:forClass sync:ManagedDocument;
      sync:managedResourceType crdt:ClientInstallation;
      solid:instanceContainer <../installations/>
   ] .
```

4. **Managed Resource Discovery:** CRDT-enabled applications query the Type Index for `sync:ManagedDocument` registrations with specific `sync:managedResourceType` values (e.g., `schema:Recipe`) and their corresponding index types (e.g., `idx:FullIndex`), enabling automatic discovery of the complete synchronization setup.

**Advantages:** Using TypeRegistration with `sync:ManagedDocument` and `sync:managedResourceType` enables managed resource discovery while protecting managed resources from incompatible applications. CRDT-enabled applications can find both data and indices through standard Solid mechanisms ([WebID Profile](https://www.w3.org/TR/webid/), [Type Index](https://github.com/solid/type-indexes)), while traditional applications remain unaware of CRDT-managed data, preventing accidental corruption.

### 4.5. Installation Identity Management

Collaborative CRDT synchronization requires stable client identity management to enable causality tracking, coordinate collaborative operations, and manage installation lifecycles. Each client installation maintains a discoverable identity document that serves as the foundation for all collaborative coordination.

Installation IDs are IRIs that reference discoverable `crdt:ClientInstallation` documents. These provide traceability, identity management for Hybrid Logical Clock entries, and collaborative lifecycle management.

**Discovery and Lifecycle:**
1. **Discovery:** Applications query the Type Index for `crdt:ClientInstallation` container location
2. **ID Generation:** Generate unique UUID v4 for each application installation
3. **Registration:** Create installation document at discovered container location
4. **Usage:** Reference installation IRI in Hybrid Logical Clock entries for all subsequent operations

**Installation Document Structure:**

```turtle
<> a sync:ManagedDocument;
   foaf:primaryTopic <#installation>;
   sync:isGovernedBy mappings:client-installation-v1 .

<#installation> a crdt:ClientInstallation;
   crdt:belongsToWebID <../profile/card#me>;
   crdt:applicationId <https://meal-planning-app.example.org/id>;
   crdt:createdAt "2024-08-19T10:30:00Z"^^xsd:dateTime;
   crdt:lastActiveAt "2024-09-02T14:30:00Z"^^xsd:dateTime .
```

**Installation ID Generation Process:**

**Recommended Approach (UUID v4):**
1. **Discover container:** Query Type Index for `crdt:ClientInstallation` container
2. **Generate UUID:** Use UUID v4 for cryptographically strong uniqueness
3. **Create IRI:** `{container-url}/{uuid}` 
4. **Register installation:** POST installation document to container
5. **Use in Hybrid Logical Clocks:** Reference full installation IRI in `crdt:installationId`

**Installation Lifecycle Management:**

*Self-Managed Properties (Installation Should Only Update Its Own):*
- **`crdt:lastActiveAt`:** Installation updates its own activity timestamp
  - **Update triggers:** First sync operation of each day
  - **Frequency:** Daily maximum to align with Management Phase operations and reduce write overhead
  - **CRDT Algorithm:** `crdt:LWW_Register`
- **`crdt:maxInactivityPeriod`:** Installation's maximum inactivity period before tombstoning (defaults to P6M)

*Identity Properties (Set Once at Creation):*
- **`crdt:belongsToWebID`**, **`crdt:applicationId`**, **`crdt:createdAt`:** Use `crdt:Immutable` or `crdt:FWW_Register` based on error handling preference

**Installation Cleanup:**
Inactive installations are tombstoned using `crdt:deletedAt` when inactive beyond their `crdt:maxInactivityPeriod`. Other installations monitor `crdt:lastActiveAt` during collaborative operations and make dormant installation tombstoning decisions as part of their sync management phase. For general tombstone mechanics, see Section 3.6 below.

### 4.6. Tombstoning and Deletion Semantics

Distributed systems require explicit deletion handling to ensure consistent data removal across all clients. The framework implements a comprehensive tombstoning approach that supports both complete resource deletion and granular property value removal while maintaining CRDT convergence properties.

#### 4.6.1. Tombstone Types and Scope

The framework uses two distinct tombstone mechanisms for different deletion scopes, both utilizing the same `crdt:deletedAt` predicate but with different merge semantics appropriate to their scope.

**Two Types of Tombstones:**

**1. Document Tombstones** (Entire Document Deletion):
- **Purpose:** Mark complete documents as deleted, affecting all resources contained within
- **Property:** `crdt:deletedAt` with OR-Set semantics applied to the document
- **Scope:** Applied to the document identifier `<doc>`, marking the entire document for cleanup
- **Use Cases:** 
  - **Application-controlled cleanup:** User-deleted documents (recipes, shopping lists, etc.)
  - **Installation management:** Inactive client installations beyond their `crdt:maxInactivityPeriod`
  - **Index lifecycle management:** Obsolete index shards during index reorganization
  - **Garbage collection:** Framework-managed cleanup of stale metadata documents

```turtle
# Document tombstone example - applied at document level
<https://alice.podprovider.org/data/shopping-entries/entry-123> 
    crdt:deletedAt "2024-09-02T14:30:00Z"^^xsd:dateTime .
```

**Document-Level Deletion Semantics (Universal Emptying):**
When applying document tombstones, implementations must perform universal emptying: remove all semantic content while preserving essential framework metadata. This applies when setting `crdt:deletedAt` such that `max(crdt:deletedAt) > max(crdt:createdAt)`. This "radical emptying" approach provides:

- **Consistent storage usage:** All tombstoned documents have predictable, minimal size
- **Conflict avoidance:** No stale content to conflict with during reactivation scenarios  
- **Simple cleanup logic:** One deletion marker controls entire document lifecycle
- **Optimal performance:** Minimal data to sync for tombstoned documents

**Universal Emptying Rule:**
```turtle
# Before tombstoning (example recipe):
<> a sync:ManagedDocument;
   sync:isGovernedBy mappings:recipe-v1;
   foaf:primaryTopic <#recipe>;
   idx:belongsToIndexShard <../indices/recipes/shard-0>,
                           <../indices/gc/2024/shard-0>;
   crdt:createdAt "2024-08-01T10:00:00Z"^^xsd:dateTime;
   crdt:clockEntry [...] .

<#recipe> a schema:Recipe;
   schema:name "Tomato Soup";
   schema:ingredients [...] .

# After tombstoning (universal emptying applied):
<> a sync:ManagedDocument;
   sync:isGovernedBy mappings:recipe-v1;
   idx:belongsToIndexShard <../indices/gc/2024/shard-0>;  # Only GC shard remains
   crdt:createdAt "2024-08-01T10:00:00Z"^^xsd:dateTime;
   crdt:deletedAt "2024-08-15T14:30:00Z"^^xsd:dateTime;
   crdt:clockEntry [...] .

# Removed during tombstoning:
# - foaf:primaryTopic and all semantic content  
# - All idx:belongsToIndexShard except GC index references
# - All application-specific properties
```

**Selective Property Retention:**
- **Framework metadata:** `rdf:type`, `sync:isGovernedBy`, `crdt:*` properties preserved
- **GC index tracking:** `idx:belongsToIndexShard` retained only for garbage collection shards
- **All other content:** Removed to minimize storage and prevent conflicts

**2. Property Tombstones** (Individual Value Deletion):
- **Purpose:** Mark specific values within multi-value properties as deleted (e.g., removing "quick" from recipe keywords)
- **Property:** `crdt:deletedAt` with RDF Reification
- **Scope:** Applied to individual property values within OR-Set or 2P-Set properties
- **Use Case:** User removes a keyword, ingredient, or other individual value from a multi-value property

#### 4.6.2. Unified Deletion Semantics

The `crdt:deletedAt` predicate is defined globally in the framework's predicate mappings with consistent OR-Set semantics across all contexts:

```turtle
# In core-v1.ttl deletion mappings
[ mc:predicate crdt:deletedAt; algo:mergeWith algo:OR_Set ]
```

**Key Properties:**

**Document-Level Deletion:**
- **Temporal Lifecycle:** Both `crdt:createdAt` and `crdt:deletedAt` are sets of timestamps (OR-Set semantics)
- **State Determination:** A document is considered deleted if `max(crdt:deletedAt) > max(crdt:createdAt)`
- **Merge Behavior:** OR-Set union across all replicas for both creation and deletion timestamps
- **Undeletion Support:** Add new `crdt:createdAt` timestamp and tombstone old `crdt:deletedAt` timestamps that are being "undone"

**Property-Level Deletion (RDF Reification):**
- **Simple Tombstone:** Property values are deleted if a corresponding RDF reification tombstone with `crdt:deletedAt` exists
- **No Creation Tracking:** Property tombstones only have `crdt:deletedAt` (no `crdt:createdAt` at value level)
- **Standard RDF Semantics:** Uses RDF reification to mark specific triples as deleted without asserting them

**Undeletion Example:**
```turtle
# Before undeletion - document is deleted (max deletion > max creation)
<doc> crdt:createdAt ["2024-01-01T10:00:00Z"] ;
      crdt:deletedAt ["2024-06-01T15:30:00Z"] .  # Document deleted

# After undeletion - add new creation, tombstone old deletion
<doc> crdt:createdAt ["2024-01-01T10:00:00Z", "2024-08-15T09:00:00Z"] ;
      crdt:deletedAt [] .  # Deletion timestamp tombstoned

# The deletion tombstone (as RDF reification):
[rdf:subject <doc> ; 
 rdf:predicate crdt:deletedAt ; 
 rdf:object "2024-06-01T15:30:00Z"^^xsd:dateTime] 
    crdt:deletedAt "2024-08-15T09:01:00Z"^^xsd:dateTime .
```

**Deletion API Design Philosophy:**

Framework deletion operates at the document level, providing a clean separation between application-controlled soft deletion and system-level cleanup:

```dart
// Document-level deletion - marks entire document for cleanup
syncLibrary.deleteDocument(documentUri);
// ↑ Framework handles document-level tombstone, affects all resources within

// Note: Direct manipulation of document metadata is NOT supported:
// syncLibrary.addTriple(documentUri, 'crdt:deletedAt', timestamp); // ILLEGAL
// ↑ Document metadata belongs to framework, not application control
```

**Key Principles:**
- **Document-Level Scope:** Deletion affects entire documents, not individual resources
- **Developer Choice:** Use framework deletion only when business-level soft deletion isn't sufficient
- **Explicit Cleanup:** Framework deletion provides eventual cleanup with retention policies

**Application vs System Deletion:**

The framework distinguishes between application-level "deletion" semantics and system-level cleanup operations:

- **Application Layer:** Developers typically implement domain-specific soft deletion (`status: "archived"`, `visibility: "hidden"`) using their own vocabulary and business logic
- **System Layer:** Framework deletion (`crdt:deletedAt`) is for true cleanup - storage optimization, retention compliance, and document lifecycle management
- **Layered Approach:** Applications may use both - soft deletion for user-facing features, framework deletion for backend cleanup policies

This separation allows developers to maintain full control over user-visible deletion semantics while leveraging the framework's sophisticated distributed cleanup infrastructure when genuine resource removal is required.

#### 4.6.3. Property Tombstone Implementation

Individual values within multi-value properties are deleted using RDF Reification tombstones:

```turtle
# Example: Tombstone for deleted keyword "quick"
<#crdt-tombstone-f8e4d2b1> a rdf:Statement;
  rdf:subject :it;
  rdf:predicate schema:keywords;
  rdf:object "quick";
  crdt:deletedAt "2024-09-02T14:30:00Z"^^xsd:dateTime .
```

**Fragment Identifiers:** Deterministic generation using XXH64 hash of canonical N-Triple prevents conflicts while allowing collaborative tombstone creation.

#### 4.6.4. Design Rationale

This framework deliberately uses fragment identifiers for reification statements rather than the more common blank nodes, reflecting the distributed coordination requirements of CRDT synchronization:

**Traditional RDF Reification:** Typically uses blank nodes since statements are considered "local to document" without inherent web identity:
```turtle
# Traditional approach (NOT used in this framework)
_:tombstone a rdf:Statement;
  rdf:subject :it;
  rdf:predicate schema:keywords;
  rdf:object "quick";
  crdt:deletedAt "2024-09-02T14:30:00Z"^^xsd:dateTime .
```

**Distributed CRDT Requirements:** The collaborative nature of CRDT synchronization requires deterministic identification of the same logical deletion across installations:

1. **Cross-Installation Coordination:** Multiple client installations must identify the same logical deletion when merging tombstone states
2. **Merge Efficiency:** Fragment identifiers are more efficient during merge operations than blank node identity resolution

**Technical Alternative:** Blank nodes with canonical form identification (Section 3.2) would also work, but fragment identifiers provide simpler merge processing and better debuggability.

**Key Insight:** While traditional RDF treats reification as document-local metadata, CRDT frameworks require deterministic identification of deletion markers across the collaborative system.

**RDF Reification Choice:** RDF Reification is semantically correct for tombstones because we need to mark statements as deleted without asserting them. RDF-Star syntax would incorrectly assert the triple.
